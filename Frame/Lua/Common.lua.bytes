require "JsonManager";
require "Logger";
require "EventDispatcher";
require "StatsReporter";
require "TableTool";
require "ShareModule";
require "LuaMonitor";
Common = {};

-- C#层的接口实现
local CSharpInterface = com.tencent.pandora.CSharpInterface;
local isDebug = CSharpInterface.IsDebug();
local Logger = Logger;

-- 自增ID,Frame为了兼容老版本，id不从C#层新增的接口取，把基础id设为10000，跟C#层区分
local increasingCallId = 10000;

-- 一些全局性的事件
Common.GAME_COMMAND = "gameCommand";
Common.PX_COMMAND = "pixuiCommand";
Common.SDK_COMMAND = "sdkCommand";
Common.CLOSE_PANEL = "closePanel";
Common.PUSH_DATA = "pushData";
require "PixUIAdapter";
require "PxFrame";
-- 重写require函数，处理SDK中增加加载lua后释放lua源代码机制后，
-- 因旧的DJCFrame 的文件组织结构不符合规范，而出现的require DJCFrame报错问题。    
-- 正确的文件组织结构规范为：
-- 1.活动/库文件夹下必须有个和文件夹同名的lua文件，作为其入口文件，
--   入口文件中只能包含 require xxx 和 执行其他模块的代码，而不能
--   定义全局table，函数等供其他模块调用的东西。
-- 2.入口文件不能被其他模块require。
-- _G.originalRequire = _G.require;
-- local function OverwriteRequire(name)
--     if name == "DJCFrame" and _G.DJCFrame ~= nil then
--         return;
--     end
--     return _G.originalRequire(name);
-- end
-- _G.require = OverwriteRequire;

local innerTimer = LuaTimer;

LuaTimer = {};
--定时器，支持两种类型。
--一次性定时器，接收两个参数。
--@param delay      第一个参数，表示LuaTimer.Add执行后，延迟多久开始执行自己的目标函数。    
--@param func       第二个参数，自定义的目标函数。
--@return           返回timerId，用于调用LuaTimer.Delete(timerId)删除定时器。

--循环定时器，接收三个参数。
--@param delay      第一个参数，表示LuaTimer.Add执行后，延迟多久开始执行自己的目标函数。 
--@param cycle      第二个参数，周期时间，每间隔cycle代表的时间，目标函数就被执行一次。
--@param func       第三个参数，自定义的目标函数。如果函数返回false，定时器就会停止执行；
--                  无返回值或返回true，定时器会持续执行，直到定时器被删除。
--@return           返回timerId，用于调用LuaTimer.Delete(timerId)删除定时器。
function LuaTimer.Add(...)
    local args = {...};
    local action;
    if #args ~= 2 and #args ~= 3 then
        Logger.ERROR("LuaTimer.Add只接收两个参数或者三个参数");
        return;
    end
    local handler = function ()
        local status, result = xpcall(function ()
            return action();
        end,function (err)
            CSharpInterface.ReportLuaError("LuaTimer error: " .. tostring(err) .. "|" .. debug.traceback());
        end);
        if not status then
            return false;
        end
        if result == false then
            return false;
        end
    end
    action = args[#args];
    args[#args] = handler;
    return innerTimer.Add(unpack(args))
end

function LuaTimer.Delete( timerId )
    innerTimer.Delete(timerId);
end

function LuaTimer.DeleteAll(  )
    Logger.ERROR("请使用LuaTimer.Delete 删除指定的Timer")
end

function Common.SafeCall(func, ...)
    if type(func) ~= "function" then
        Logger.ERROR("Common.SafeCall 接收到的参数func不是函数，请检查")
        return nil,false
    end

    local args = {...}

    local status, result = xpcall(function ()
            return func(unpack(args));
        end,function (err)
            local msg = "Common.SafeCall error: " .. tostring(err) .. "|" .. debug.traceback()
            print(msg)
            CSharpInterface.ReportLuaError("Common.SafeCall error: " .. tostring(err) .. "|" .. debug.traceback());
        end);

        if not status then
            return nil,false
        else
            return result,true
        end
end

function Common.GetLogger()
    return Logger;
end

-- 获取平台类型
-- @return 当前平台类型
-- 平台类型包括:pc android mac ios
function  Common.GetPlatformDesc()
    return CSharpInterface.GetPlatformDescription();
end

-- 获取SDK版本号
-- @return SDK版本号
function Common.GetSDKVersion()
    return CSharpInterface.GetSDKVersion();
end

-- 清理cache
function Common.ClearCache()
    CSharpInterface.ClearCache()
end

-- 释放未使用的assets
function Common.UnloadUnusedAssets()
    CSharpInterface.UnloadUnusedAssets();
end

-- 获取用户数据
-- @return UserData
--
-- UserData包括以下字段，均为string类型：
-- sRoleId       角色ID
-- sOpenId       用户标识
-- sServiceType  游戏简称,如完美世界（wmsj，这个是跟接入AMS系统时的代号一致）
-- sAcountType   帐号类型：qq(手Q) wx(微信) ttpp(游客)
-- sArea         大区号，正式环境下微信为1，手Q为2，测试环境下各业务可能各不相同
-- sPartition　　小区号（区服）
-- sAppId        应用ID
-- sAccessToken  登录token
-- sPayToken     支付token,手Q有单独的支付token，微信支付token和登录token相同
-- sGameVer      游戏版本号
-- sPlatID       平台ID：0(ios) 1(android)
-- sQQInstalled  手Q是否已安装，0（未安装），1（已安装）
-- sWXInstalled  微信是否已安装，0（未安装），1（已安装）
-- sGameName     游戏名称，跟sServiceType一致
-- sMSDKGameID   只有接入GCloud的业务使用此字段，游戏在MSDK平台注册的应用ID
-- sSdkVersion   潘多拉SDK版本号，如SPEEDM-IOS-1，在SDK升级时会改变，也用于云端规则匹配
-- sLevel        玩家等级，部分游戏在登录时可能获取不到玩家等级，此字段相应为空
-- sVender       游戏下载安装的渠道号，如通过应用宝安装，渠道号为2002
-- sOS           操作系统类型，1 - Android, 2 - iOS, 3 - Web，4 - Linux, 5 - windows
--               只有接入GCloud的业务会使用sOS字段
-- sChannelID    登录渠道，1 - 微信(WeChat)，2 - 手Q(mqq)，3 - 游客(Guest)，4 - Facebook，5 - GameCenter, 
--               6 - GooglePlay, 100 - 自建账号体系，只有接入GCloud的业务会使用sChannelID字段
function Common.GetUserData()
    return CSharpInterface.GetUserData();
end

-- 提供给JS使用的方法
function Common.GetUserDataTable()
    local ud = Common.GetUserData();
    local tb = {};
    for v in Slua.iter(ud.Keys) do
        tb[v] = ud[v];
    end
    return tb;
end


--因userdata类型没法传递给js，所以此处先将userdata里的数据转存为lua table，如果userdata中有新增字段，此处需要修改
function Common.GetUserDataForJS()
    local userDataTable = {};
    local ud = CSharpInterface.GetUserData();
    userDataTable["sRoleId"] = ud.sRoleId;
    userDataTable["sOpenId"] = ud.sOpenId;
    userDataTable["sServiceType"] = ud.sServiceType;
    userDataTable["sAcountType"] = ud.sAcountType;
    userDataTable["sArea"] = ud.sArea;
    userDataTable["sPartition"] = ud.sPartition;
    userDataTable["sAppId"] = ud.sAppId;
    userDataTable["sAccessToken"] = ud.sAccessToken;
    userDataTable["sPayToken"] = ud.sPayToken;
    userDataTable["sGameVer"] = ud.sGameVer;
    userDataTable["sPlatID"] = ud.sPlatID;
    userDataTable["sQQInstalled"] = ud.sQQInstalled;
    userDataTable["sWXInstalled"] = ud.sWXInstalled;
    userDataTable["sGameName"] = ud.sGameName;
    userDataTable["sMSDKGameID"] = ud.sMSDKGameID;
    userDataTable["sSdkVersion"] = ud.sSdkVersion;
    userDataTable["sLevel"] = ud.sLevel;
    userDataTable["sVender"] = ud.sVender;
    userDataTable["sOS"] = ud.sOS;
    userDataTable["sChannelID"] = ud.sChannelID;
    return userDataTable;
end

-- 刷新登录和支付token，调用此接口后，再通过Common.GetUserData()获取到的用户信息中就是最新的token
function Common.RefreshUserDataTokens()
    return CSharpInterface.RefreshUserDataTokens();
end

-- 获取总开关
-- @return 总开关开启，返回true；否则返回false
function Common.GetTotalSwitch()
    return CSharpInterface.GetTotalSwitch();
end

-- 获取功能开关
-- @param funcName 要获取的功能开关名称
-- @return         开关开启返回true，否则返回false
function Common.GetFunctionSwitch(funcName)
    return CSharpInterface.GetFunctionSwitch(funcName);
end

-- 写文件
-- 文件超过一定时间后(目前是7天)将被自动删除
-- @param fileName 文件名，相对路径，绝对路径是pandora的cookies目录+fileName
-- @param content  文件内容
-- @return         写文件成功返回true；否则返回false
function Common.WriteCookie(fileName, content)
    return CSharpInterface.WriteCookie(fileName, content);
end

-- 读文件
-- @param fileName 文件名，相对路径，绝对路径是pandora的cookies目录+fileName
-- @return         读取成功返回文件内容，读取失败返回空字符串
function Common.ReadCookie(fileName)
    return CSharpInterface.ReadCookie(fileName);
end

-- lua层向游戏发送请求
-- @param jsonStr  向游戏传递的json请求串
function Common.CallGame(jsonStr)
    CSharpInterface.LuaCallGame(jsonStr);
end

-- lua层向游戏发送请求
-- @param tbl 参数为lua table类型
function Common.CallGameByTable(tbl)
    Common.CallGame(JsonManager.EncodeJson(tbl));
end

-- lua层向pixui发送请求
-- @param json 向游戏传递的json请求串
function Common.CallPx(windowId, jsonStr)
    CSharpInterface.LuaCallPx(windowId, jsonStr);
end
-- tnm2上报机制
-- @param content    内容，string类型
-- @param id         id，number类型
-- @param type       类型，number类型，0：叠加类型，1：平均值类型，2：字符型告警类型
function Common.Report(content, id, type)
    CSharpInterface.Report(content, id, type);
end

-- 上报错误接口
-- @param errMsg     错误信息，string类型
-- @param errorCode  错误码，number类型
function Common.ReportError(errMsg, errorCode)
    if errorCode == nil then
        errorCode = 0;
    end
    CSharpInterface.ReportError(errMsg, errorCode);
end

-- 开放平台应用上报监控数据
-- @param content    内容，string类型
-- @param id         id，string类型
-- @param type       类型，number类型，0：叠加类型，1：平均值类型，2：字符型告警类型
-- @param appId      开放平台应用Id
function Common.ReportToTdm(content, id, reportType, appId, appKey)
	appId = appId or 0;
    -- CSharpInterface.ReportToTdm(tostring(content), tostring(id), reportType, appId);
end

-- 开放平台应用上报监控数据
-- @param content    内容，string类型
-- @param id         tdm id，string类型
-- @param type       类型，number类型，0：叠加类型，1：平均值类型，2：字符型告警类型
-- @param appId      开放平台应用Id
function Common.ReportJSExceptionToTdm(content, appId, appKey)
    if not appId then
        return
    end
    CSharpInterface.ReportToTdm(tostring(content), "JS_SCRIPT_EXCEPTION_DETAIL", 2, appId);
end


Common.TIMEOUT_MESSAGE = "error form lua, packet sending timeout";

-- lua层向server发送请求
-- @param commandId 请求命令字，number类型，如拉取活动为9000
-- @param request   请求串，string类型
-- @param callback  处理响应的回调函数，回调函数被执行时，最后一个参数是返回的响应数据
-- @param ...       可变参数列表，此参数列表会排在前面传递回callback
function Common.CallBroker(commandId, request, callback, ...)
    local id = Common.GenCallId();
    EventDispatcher.AddEventListener(id, callback, ...);
    -- 启动超时处理定时器
    LuaTimer.Add(10 * 1000, 0, function()
        if EventDispatcher.HasEventListener(id) == true then
            -- 构建一个和Pandora请求回包格式相同的超时返回包
            local timeoutResponse = "{\"ret\":\"-1\",\"netRet\":\"-1\",\"err_msg\":\"" .. Common.TIMEOUT_MESSAGE .. "\"}";
            Common.ExecuteCallback(id, timeoutResponse);
        end
    end)

	 CSharpInterface.CallBroker(id, request, commandId);
end

-- lua层向server发送请求扩展接口，用于开放平台时可以传递subCommandId，applicationId
-- @param commandId 请求命令字，number类型，如拉取活动为9000
-- @param subCommandId 请求子命令字，number类型，如拉取活动为10000
-- @param applicationId Pandora应用Id
-- @param request   请求串，string类型
-- @param callback  处理响应的回调函数，回调函数被执行时，最后一个参数是返回的响应数据
-- @param ...       可变参数列表，此参数列表会排在前面传递回callback
function Common.CallBrokerExtend(commandId,subCommandId,applicationId,request, callback, ...)
	local id = CSharpInterface.GetSeqId();
    EventDispatcher.AddEventListener(id, callback, ...);

    -- 启动超时处理定时器
    LuaTimer.Add(10 * 1000, 0, function()
        if EventDispatcher.HasEventListener(id) == true then
            -- 构建一个和Pandora请求回包格式相同的超时返回包
            local timeoutResponse = "{\"ret\":\"-1\",\"netRet\":\"-1\",\"err_msg\":\"" .. Common.TIMEOUT_MESSAGE .. "\"}";
            Common.ExecuteCallback(id, timeoutResponse);
        end
    end)

	CSharpInterface.CallBroker(id, request, commandId,subCommandId,applicationId,1,10);
end

-- 获取应用的appid
function Common.GetAppId(moduleName)
	return CSharpInterface.GetAppId(moduleName);
end

-- 获取应用的版本号
function Common.GetAppVersion(appId)
	return CSharpInterface.GetAppVersion(appId)
end

-- 跟Common.CallBrokerExtend方法类型，区别在于可以broker使用应用设置的私有broker
-- @param commandId 请求命令字，number类型，如拉取活动为9000
-- @param subCommandId 请求子命令字，number类型，如拉取活动为10000
-- @param applicationId Pandora应用Id
-- @param appKey 注册app时获得的key
-- @param requestBody   请求结构体， Object 类型
-- @param callback  处理响应的回调函数，回调函数被执行时，最后一个参数是返回的响应数据
-- @param ...       可变参数列表，此参数列表会排在前面传递回callback
function Common.CallApplicationBroker(commandId, subCommandId, applicationId, appKey, requestBodyObject, callback, ...)
	local id = CSharpInterface.GetSeqId();
	local request = Common.GenCallApplicationBrokerRequest(id, subCommandId, applicationId, appKey, requestBodyObject)
    EventDispatcher.AddEventListener(id, callback, ...);

    -- 启动超时处理定时器
    LuaTimer.Add(10 * 1000, 0, function()
        if EventDispatcher.HasEventListener(id) == true then
            -- 构建一个和Pandora请求回包格式相同的超时返回包
            local timeoutResponse = "{\"ret\":\"-1\",\"netRet\":\"-1\",\"err_msg\":\"" .. Common.TIMEOUT_MESSAGE .. "\"}";
            Common.ExecuteCallback(id, timeoutResponse);
        end
    end)

    CSharpInterface.CallApplicationBroker(id, request, commandId, subCommandId,applicationId,1,10);
end

function Common.GenCallApplicationBrokerRequest(id, subCommandId, applicationId, appKey, requestbodyProxyDataObject)
    local md5 = require("md5");
    local userData = Common.GetUserData()
    local header = {};
    header["cmd_id"]        = tostring(subCommandId); -- 管理端拉取活动id
    header["sdk_version"]   = Common.GetSDKVersion();
    header["game_app_id"]   = userData.sAppId;
    header["plat_id"]       = userData.sPlatID;
    header["acc_type"]      = userData.sAcountType;
    header["access_token"] = userData.sAccessToken;
    header["area_id"]       = userData.sArea;
    header["patition_id"]   = userData.sPartition;
    header["open_id"]       =  userData.sOpenId;
    header["role_id"]       =  userData.sRoleId;
    header["timestamp"]     = tostring(Common.GetNowMilliseconds());
    header["pdr_appid"]     = tostring(applicationId);
    header["sign"]  = md5.sumhexa(Common.CalculateCallApplicationBrokerSign(header, appKey));
    header["pdr_version"]     = tostring(Common.GetAppVersion(applicationId));
    header["seq_id"]        = tostring(id);
    header["channel_id"]    = "";	--这三个字段为空
	header["act_style"]     = "";
	header["info_id"]    = "";
	header["source"] = 3;
	header["msg_type"]      = "1";    --请求1，应答2

    local body = requestbodyProxyDataObject;
    local request = {};
    request["head"] = header;
	request["body"] = body;
	return JsonManager.EncodeJson(request);
end

-- 拼接 CallApplicationBroker 的签名
-- @param headerTable 请求header
-- @param appkey 应用的appkey
function Common.CalculateCallApplicationBrokerSign(headerTable, appkey)
	--字母排序
	function pairsByKeys(t)
		local a = {}
		for n in pairs(t) do
			a[#a + 1] = n
		end
		table.sort(a)
		local i = 0;
		return function()
			i = i + 1
			return a[i], t[a[i]]
		end
	end

	local signTable= {};
	for key, value in pairsByKeys(headerTable) do
		table.insert(signTable, tostring(key).."="..tostring(value));
	end
	table.insert(signTable, "appkey=" .. tostring(appkey));
	return table.concat(signTable, "&");
end

--获取url指定的图片
-- @param url           图片的地址
-- @param callback      回调函数，如果图片加载成功，图片的Texture会作为最后一个参数传递给callback
-- @param ...           可变参数列表，此参数列表会排在前面传递回callback
function Common.GetImage(url, callback, ...)
    local id = Common.GenCallId();
    EventDispatcher.AddEventListener("ShowImage_" .. url, callback, ...);
    EventDispatcher.AddEventListener(id, Common.GetImageCallback);
    CSharpInterface.LoadImage(url, false, id);
end

function Common.GetImageCallback(jsonStr)
    local json = JsonManager.DecodeJson(jsonStr);
    if json ~= nil and tonumber(json["RetCode"]) == 0 then
        local texture = Common.GetAsset(json["Url"]);
        local evtType = "ShowImage_" .. json["Url"];
        EventDispatcher.DispatchEvent(evtType, texture);
        EventDispatcher.RemoveEventAllListener(evtType);
    end
end

-- 获取url指定的文本
-- @param url           文本的地址
-- @param callback      回调函数，如果文本加载成功，文本会作为最后一个参数传递给callback
-- @param ...           可变参数列表，此参数列表会排在前面传递回callback
function Common.GetText(url, callback, ...)
    local id = Common.GenCallId();
    EventDispatcher.AddEventListener(id, callback, ...);
    CSharpInterface.LoadText(url, id);
end

-- 创建面板
-- @param panelName    面板名称
-- @param callback     创建面板完成后的回调函数，若创建面板成功，面板的gameobject会作为最后一个参数传递给callback；
-- @param ...          可变参数列表，此参数列表会排在前面传递回callback
function Common.CreatePanel(panelName, callback, ...)
    local id = Common.GenCallId();
    EventDispatcher.AddEventListener("CreatePanel_" .. panelName, callback, ...);
    EventDispatcher.AddEventListener(id, Common.CreatePanelCallback);
    CSharpInterface.CreatePanel(id, panelName);
end

function Common.CreatePanelCallback(jsonStr)
    local panelGameObject = nil;
    local json = JsonManager.DecodeJson(jsonStr);
    if json ~= nil and json["RetCode"] ~= nil and tonumber(json["RetCode"]) == 0 and json["PanelName"] ~= nil then
        local panelName = json["PanelName"];
        panelGameObject = Common.GetPanel(panelName);
        local createPanelEventType = "CreatePanel_" .. panelName;
        EventDispatcher.DispatchEvent(createPanelEventType, panelGameObject);
        EventDispatcher.RemoveEventAllListener(createPanelEventType);
        Common.ShowLogo(panelName, panelGameObject, 0, 0);
    end
end

-- 关闭所有pandora面板，需要所有活动都注册了对Common.CLOSE_PANEL事件的监听
function Common.CloseAllPanel()
    EventDispatcher.DispatchEvent(Common.CLOSE_PANEL, "all");
end

-- 关闭指定名称的pandora面板，需要对应活动注册了对Common.CLOSE_PANEL事件的监听
-- @param panelName    面板名称
function Common.ClosePanel(panelName)
    EventDispatcher.DispatchEvent(Common.CLOSE_PANEL, panelName);
end

-- 获取面板
-- @param panelName 面板名称
function Common.GetPanel(panelName)
    return CSharpInterface.GetPanel(panelName);
end

-- 关闭面板
-- @param panelName 面板名称
function Common.DestroyPanel(panelName)
    CSharpInterface.DestroyPanel(panelName);
    Slua.ClearObjectCache(panelName);
    if Common.GetFunctionSwitch("stressTesting") == true then
        Common.LuaGC();
        CSharpInterface.ForceDeleteZeroReferenceAsset();
        Common.UnloadUnusedAssets();
    end
end

-- 显示图片
-- @param panelName 面板名称，在哪个面板上显示图片
-- @param url       图片的url
-- @param imageHost 显示图片的UITexture/Image所在的节点
-- @isCacheInMemory 图片加载完毕后，是否缓存在内存中
-- @param callback  回调函数，显示图片结果将会以最后一个参数传递给callback
--                  其格式是{"RetCode":"0", "PanelName":"PanelName", "Url":"Url"}，
--                  其中RetCode的值为0表示显示图片成功，否则失败
-- @param ...       可变参数列表，此参数列表会排在前面传递回callback
function Common.ShowImage(panelName, url, imageHost, isCacheInMemory, callback, ...)
    local id = Common.GenCallId();
    EventDispatcher.AddEventListener(id, callback, ...);
    CSharpInterface.ShowImage(panelName, url, imageHost, false, id);
end

-- 显示头像，参数和ShowImage含义相同，支持Gif格式
function Common.ShowPortrait(panelName, url, imageHost, isCacheInMemory, callback, ...)
    local id = Common.GenCallId();
    EventDispatcher.AddEventListener(id, callback, ...);
    CSharpInterface.ShowPortrait(panelName, url, imageHost, isCacheInMemory, id);
end

-- 下载图片到本地磁盘
-- @param url   图片的url
function Common.CacheImage(url)
    CSharpInterface.CacheImage(url);
end

-- 判断图片是否已经下载到本地磁盘
-- @param url   图片的url
-- @return      图片已下载到本地磁盘返回true；否则返回false
function Common.IsImageCached(url)
    return CSharpInterface.IsImageCached(url);
end

-- 下载文件到本地磁盘
-- @param url   下载的url
function Common.CacheAsset(url, callback)
    CSharpInterface.CacheAsset(url, callback);
end

-- 判断文件是否已经下载到本地磁盘
-- @param url   下载的url
-- @return      文件已下载到本地磁盘返回true；否则返回false
function Common.IsAssetCached(url)
    return CSharpInterface.IsAssetCached(url);
end

-- 释放强引用资源（如果url指定的资源被缓存在强引用池中，使用此接口减少在强引用池中的引用计数，
-- 当计数为0后，该资源会被释放）
-- @param url       资源的url
function Common.ReleaseAsset(url)
    CSharpInterface.ReleaseAsset(url);
end

-- 获取资源的通用接口
-- @param url       资源的url
function Common.GetAsset(url)
    return CSharpInterface.GetAsset(url);
end

-- 加载普通Prefab
-- @param url       Prefab的url
-- @isCacheInMemory Prefab加载完毕后，是否缓存在内存中
-- @param callback  回调函数，Prefab加载后会被实例化，实例化得到的GameObject会传给callback
function Common.LoadGameObject(url, isCacheInMemory, callback)
    CSharpInterface.LoadGameObject(url, isCacheInMemory, callback);
end

-- 加载AssetBundle
-- @param url       AssetBundle的url
-- @param callback  加载完成后的回调函数，加载到的AssetBundle会做为最后一个参数传给callback
-- @param ...       可变参数列表，此参数列表会排在前面传递回callback
function Common.LoadAssetBundle(url, callback, ...)
    local id = Common.GenCallId();
    EventDispatcher.AddEventListener("LoadAssetBundle_" .. url, callback, ...);
    EventDispatcher.AddEventListener(id, Common.OnLoadAsset);
    CSharpInterface.LoadAssetBundle(url, id);
end

function Common.OnLoadAsset(jsonStr)
    local jsonTable = JsonManager.DecodeJson(jsonStr);
    local url = jsonTable["Url"];
    if tonumber(jsonTable["RetCode"]) ~= 0 then
        Logger.ERROR("资源加载失败，Url： " .. jsonTable["Url"]);
    end
    local assetType = jsonTable["Type"];
    local eventType = "";
    if assetType == "UnityEngine.AssetBundle" then
        eventType = "LoadAssetBundle_" .. url;
    elseif assetType == "UnityEngine.GameObject" then
        eventType = "LoadGameObject_" .. url
    end
    EventDispatcher.DispatchEvent(eventType, Common.GetAsset(url));
    EventDispatcher.RemoveEventAllListener(eventType);
end

-- 发送http请求
-- @param url        请求的url
-- @param reqParams  请求的参数
-- @param isPost     bool型参数，true表示POST请求，false表示GET请求
-- @param callback   回调函数，请求结果会作为最后一个参数传递给callback
--                   其格式是{"RetCode":"0", "Resp":"XXXXXXXXXXX"}，
--                   其中RetCode的值为0表示成功，否则失败；Resp字段中的数据是真正的响应数据
-- @param ...        可变参数列表，此参数列表会排在前面传递回callback
function Common.SendWwwRequest(url, reqParams, isPost, callback, ...)
    local id = Common.GenCallId();
    EventDispatcher.AddEventListener(id, callback, ...);
    CSharpInterface.LoadWww(url, reqParams, isPost, id);
end

-- 发送携带二进制数据的http请求，只能用于POST请求，一般用于上传文件
-- @param url           请求的url
-- @param reqParams     请求的参数
-- @param binaryData    二进制数据,Byte[]类型
-- @param isPost        bool型参数，这里只能为true
-- @param callback      回调函数，请求结果会作为最后一个参数传递给callback
--                      其格式是{"RetCode":"0", "Resp":"XXXXXXXXXXX"}，
--                      其中RetCode的值为0表示成功，否则失败；Resp字段中的数据是真正的响应数据
-- @param ...           可变参数列表，此参数列表会排在前面传递回callback
function Common.SendWwwRequestWithBinaryData(url, reqParams, binaryData, isPost, callback, ...)
    local id = Common.GenCallId();
    EventDispatcher.AddEventListener(id, callback, ...);
    CSharpInterface.LoadWwwWithBinaryData(url, reqParams, binaryData, isPost, id);
end

-- 埋点上报
-- 接口说明请参见 StatsReporter.lua.bytes
function Common.ReportStats(iModule, iChannelId, iType, iActId, iJumpType, sJumpUrl,
                            sRecommendId, iChangjingId, iGoodsId, iCountId, iFee,
                            iCurrencyType, iActStyle, iFlowId,extendList)
    StatsReporter.Report(Common.GetUserData(), Common.GenCallId(), iModule, iChannelId, iType, iActId, iJumpType, sJumpUrl,
                            sRecommendId, iChangjingId, iGoodsId, iCountId, iFee,
                            iCurrencyType, iActStyle, iFlowId,extendList);
end

-- 开放平台埋点上报。 和旧版本上报的区别是 iCurrencyType = "openplat", 所以用户可以不传这个字段
-- 接口说明请参见 StatsReporter.lua.bytes
function Common.OpenPlatformReportStats(iModule, iChannelId, iType, iActId, iJumpType, sJumpUrl,
    sRecommendId, iChangjingId, iGoodsId, iCountId, iFee,
    iCurrencyType, iActStyle, iFlowId,extendList)
StatsReporter.Report(Common.GetUserData(), Common.GenCallId(), iModule, iChannelId, iType, iActId, iJumpType, sJumpUrl,
    sRecommendId, iChangjingId, iGoodsId, iCountId, iFee,
    "openplat", iActStyle, iFlowId,extendList);
end

-- 道聚城购买流程上报耗时，为重用道聚城提取log基础设施，字段保持和寻仙中一致
-- @param type              上报类型
-- @param responseRet       Pandora返回消息最外层状态码
-- @param responseBodyRet   Pandora返回消息body状态码
-- @param djcResult         道聚城返回内容
-- @param djcEventId        道聚城EventId
-- @param amsId             AMS ID
-- @param sendTime          发送请求包时间戳
-- @param receiveTime       收到回包时间戳
function Common.ReportTimeSpend(type, responseRet, responseBodyRet, djcResult, djcEventId, amsId, sendTime, receiveTime)
    local tbl = {};
    tbl.type = type;
    tbl.jsonNetRet = "0";
    tbl.jsonRet = tostring(responseRet);
    tbl.jsonRespBodyRet = tostring(responseBodyRet);
    tbl.jsonDjcResult = djcResult;
    tbl.jsonDjcEventid = djcEventId;
    tbl.jsonAmsId = amsId;
    tbl.socketReceived = tostring(receiveTime);            -- c#层收到回包的时间，因为c#到Lua层时间消耗小于1ms，socketReceived取值luaReceived
    tbl.luaHeader = tostring(sendTime);
    tbl.luaSend = tostring(sendTime);
    tbl.luaReceived = tostring(receiveTime);
    tbl.luaDecode = tostring(Common.GetNowMilliseconds()); -- 最后执行完回调时间戳
    local content = "[DJC-REPORT][CallServerTimeDiffer] " .. JsonManager.EncodeJson(tbl);
    Common.Report(content, 0, 0);
end

-- 接受游戏的消息
-- @param jsonStr          从游戏发送过来的json格式消息
function Common.CommandFromGame(jsonStr)
    EventDispatcher.DispatchEvent(Common.GAME_COMMAND, jsonStr);
end

-- 接受pixui的消息
function Common.CommandFromPx(windowId, jsonStr)
    EventDispatcher.DispatchEvent(Common.PX_COMMAND, windowId, jsonStr);
end

-- 接受SDK C#层消息
function Common.CommandFromSDK(jsonStr)
    EventDispatcher.DispatchEvent(Common.SDK_COMMAND, jsonStr);
end

-- 打印table
-- 接口说明请参见 TableTool.lua.bytes
function Common.TablePrinter(t, name, indent)
    if isDebug == true then
        TableTool.Print(t, name, indent);
    end
end

-- 获取table的大小
-- 接口说明请参见 TableTool.lua.bytes
function Common.GetTableSize(t)
    TableTool.GetSize(t);
end

-- 获取当前时间戳，单位为毫秒
function Common.GetNowMilliseconds()
    return CSharpInterface.NowMilliseconds();
end

-- 生成全局唯一的ID
function Common.GenCallId()
    increasingCallId = increasingCallId + 1
    return increasingCallId
end

-- C#层回调，活动中不会调用
function Common.ExecuteCallback(id, jsonStr)
    if id == 0 then
        Common.OnGetPushData(jsonStr);
        return;
    end
    EventDispatcher.DispatchEvent(id, jsonStr);
    EventDispatcher.RemoveEventAllListener(id);
end

function Common.OnGetPushData(jsonStr)
    EventDispatcher.DispatchEvent(Common.PUSH_DATA, jsonStr);
end

-- 显示Pandora logo，已弃用
function Common.ShowLogo(panelName, rootGameObject, x, y)
    --[[
    local remoteConfig = CSharpInterface.GetRemoteConfig();
    if remoteConfig.isShowLogo == true then
        --UGUI方案
        local go = UnityEngine.GameObject("Image_logo");
        local image = go:AddComponent(UnityEngine.UI.Image);

        go.transform:SetParent(rootGameObject.transform);
        go.transform.localScale = UnityEngine.Vector3(1, 1, 1);
        go.transform.localRotation = UnityEngine.Vector3(0, 0, 0);
        go.transform.localPosition = UnityEngine.Vector3(x, y, 0);
        Common.ShowImage(panelName, "http://down.game.qq.com/pandora/she/20170314113920/logo.png", go, false, function()
            image:SetNativeSize();
            local rectTransform = go:GetComponent(UnityEngine.RectTransform);
            rectTransform.anchorMin = UnityEngine.Vector2(0, 0);
            rectTransform.anchorMax = UnityEngine.Vector2(0, 0);
            rectTransform.pivot = UnityEngine.Vector2(0, 0);
        end );


        --NGUI方案
        local go = UnityEngine.GameObject("Image_logo");
        local uitexture = go:AddComponent(UITexture);

        go.transform:SetParent(rootGameObject.transform);
        go.transform.localScale = UnityEngine.Vector3(1, 1, 1);
        Common.GetImage("http://down.game.qq.com/pandora/she/20170314113920/logo.png", function(texture)
            uitexture.mainTexture = texture;
            uitexture.depth = 9999;         --由于这是用于汇报用的，所以把层级尽量往高提，不够还可以再提
            uitexture:MakePixelPerfect();
            local referenceHalfX = 568;     --相应业务屏幕参考尺寸X的一半
            local referenceHalfY = 320;     --相应业务屏幕参考尺寸Y的一半
            local localX = (uitexture.localSize.x * 0.5) - referenceHalfX;
            local localY = (uitexture.localSize.y * 0.5) - referenceHalfY;
            go.transform.localPosition = UnityEngine.Vector3(localX, localY, go.transform.position.y);
        end);
    end]]
end

-- lua层垃圾回收
function Common.LuaGC()
    collectgarbage("collect");
end

--结构化消息分享到微信
--接口说明参见 ShareModule.lua.bytes
function Common.ShareStructMessageToWX(title,desc,imgUrl,userOpenId,mediaTagName,messageExt,extraJson)
    ShareModule.ShareStructMessageToWX(title,desc,imgUrl,userOpenId,mediaTagName,messageExt,extraJson);
end

--结构化消息分享到QQ
--接口说明参见 ShareModule.lua.bytes
function Common.ShareStructMessageToQQ(title,desc,imgUrl,targetUrl,isToSession)
    ShareModule.ShareStructMessageToQQ(title,desc,imgUrl,targetUrl,isToSession);
end

--大图分享到微信
--接口说明参见 ShareModule.lua.bytes
function Common.SharePhotoToWX(photoGameObject,isToSession,mediaTagName,messageExt,messageAction)
    ShareModule.SharePhotoToWX(photoGameObject,isToSession,mediaTagName,messageExt,messageAction);
end

--预置大图分享到微信
--接口说明参见 ShareModule.lua.bytes
function Common.SharePresetPhotoToWX(isToSession,mediaTagName,messageExt,messageAction,imgUrl,shareType,actionId)
    ShareModule.SharePresetPhotoToWX(isToSession,mediaTagName,messageExt,messageAction,imgUrl,shareType,actionId);
end

--大图分享到QQ
--接口说明参见 ShareModule.lua.bytes
function Common.SharePhotoToQQ(photoGameObject,isToSession)
    ShareModule.SharePhotoToQQ(photoGameObject,isToSession);
end

--预置大图分享到QQ
--接口说明参见 ShareModule.lua.bytes
function Common.SharePresetPhotoToQQ(isToSession,imgUrl,shareType,actionId)
    ShareModule.SharePresetPhotoToQQ(isToSession,imgUrl,shareType,actionId)
end

--结构化消息分享到QQ同玩好友（即QQ后端分享）
--接口说明参见 ShareModule.lua.bytes
function Common.ShareStructMessageToQQGameFriend(title,desc,previewText,imgUrl,targetUrl,userOpenId,gameTag,msdkExtInfo)
    ShareModule.ShareStructMessageToQQGameFriend(title,desc,previewText,imgUrl,targetUrl,userOpenId,gameTag,msdkExtInfo);
end

--链接分享到微信
--接口说明参见 ShareModule.lua.bytes
function Common.ShareUrlToWX(title,desc,imgUrl,targetUrl,userOpenId,isToSession,mediaTagName,messageExt,extraJson)
    ShareModule.ShareUrlToWX(title,desc,imgUrl,targetUrl,userOpenId,isToSession,mediaTagName,messageExt,extraJson);
end

--小程序分享到微信
--接口说明参见 ShareModule.lua.bytes
function Common.ShareMiniAppToWX(title,desc,imgUrl,webpageUrl,userName,path,withShareTicket,programType,userOpenId,isToSession,mediaTagName,messageExt,messageAction)
    ShareModule.ShareMiniAppToWX(title,desc,imgUrl,webpageUrl,userName,path,withShareTicket,programType,userOpenId,isToSession,mediaTagName,messageExt,messageAction);
end

--小程序分享到QQ
--接口说明参见 ShareModule.lua.bytes
function Common.ShareMiniAppToQQ(title,desc,imgUrl,url,miniProgramAppid,miniProgramPath,programType,isToSession)
    ShareModule.ShareMiniAppToQQ(title,desc,imgUrl,url,miniProgramAppid,miniProgramPath,programType,isToSession);
end

-- 跳转  SDK对接时，跳转游戏参数格式确定后，需补充此接口说明
-- @param jumpType      跳转类型，string类型，可选值如下
--                      pandoraOpenUrl为使用MSDK浏览器打开网页
--                      pandoraGoSystem为跳转游戏界面
--                      pandoraGoPandora为跳转Pandora界面
-- @param content       跳转参数，string类型，跳转类型不同，参数格式不同
function Common.Jump(jumpType, content)
    if jumpType == "pandoraOpenUrl" then
        content = Common.AppendGeneralParametersForUrl(content);
    end
    CSharpInterface.Jump(jumpType, content);
end

-- 播放游戏内声音文件
-- @param id            声音文件的id，string类型
function Common.PlaySound(id)
	CSharpInterface.PlaySound(id);
end

-- 获取游戏内最新货币数量
-- currency1 一级代币,currency2 二级代币,key值固定，对接时游戏侧需按潘多拉的需求设置代币的key
function Common.GetCurrency()
    local currency = { ["currency1"] = - 1, ["currency2"] = - 1 }
    local currencyDict = CSharpInterface.GetCurrency();
    if currencyDict:ContainsKey("currency1") then
        currency["currency1"] = tonumber(currencyDict:getItem("currency1"))
    end
    if currencyDict:ContainsKey("currency2") then
        currency["currency2"] = tonumber(currencyDict:getItem("currency2"))
    end
    return currency;
end

-- 显示游戏内物品格子
-- @param go           物品格子挂载点
-- @param itemId       物品Id
-- @param itemCount    物品数量
function Common.ShowItem(go, itemId, itemCount)
	CSharpInterface.ShowItem(go, itemId, itemCount);
end

-- 显示游戏内物品icon图片
-- @param go           图片挂载点
-- @param itemId       物品Id
function Common.ShowItemIcon(go, itemId)
	CSharpInterface.ShowItemIcon(go, itemId);
end

-- 显示游戏内物品Tips
-- @param go           Tips挂载点
-- @param itemId       物品Id
function Common.ShowItemTips(go, itemId)
	CSharpInterface.ShowItemTips(go, itemId);
end

-- 克隆GameObject并挂载到指定父节点下
-- @param template     模板GameObject
-- @param name         对象的名字
-- @param parent       父节点GameObject
-- @return             返回克隆得到的GameObject
function Common.CloneAndAddToParent(template, name,  parent)
    return CSharpInterface.CloneAndAddToParent(template, name,  parent)
end

-- 检查玩家是否使用模拟器
function Common.IsEmulatorDevice()
    -- 腾讯助手 DeviceModel=Tencent virtual machine 2
    -- 网易MuMu DeviceModel=Netease MuMu
    -- 夜神模拟器 设备信息与真机一模一样，不好做判断
    local deviceModel = UnityEngine.SystemInfo.deviceModel;
    if string.find(deviceModel, "virtual") ~= nil or string.find(deviceModel, "MuMu") ~= nil then 
        return true;
    end
    local operatingSystem = UnityEngine.SystemInfo.operatingSystem;
    if string.find(operatingSystem, "kot49h/eng.bruce") ~= nil then   -- 腾讯助手 自定义设备型号的情况
        return true;
    end
    local graphicsDeviceName = UnityEngine.SystemInfo.graphicsDeviceName;
    if string.find(graphicsDeviceName, "direct3d11") ~= nil then  -- 模拟器 显卡为D3D的情况
        return true;
    end 
    return false;
end

-- 将2019-10-31 17:58:30形式时间转换为以秒为单位的时间戳
-- @param timeStamp     字符串形式的时间戳
-- @return              返回以秒为单位的时间戳
function Common.ConvertTimeStamp(timeStamp)
    if timeStamp == "" or timeStamp == nil then
        return 0;
    end
    local pattern = "(%d+)-(%d+)-(%d+) (%d+):(%d+):(%d+)";
    local sYear, sMonth, sDay, sHour, sMinute, sSeconds = timeStamp:match(pattern);
    return os.time( { year = sYear, month = sMonth, day = sDay, hour = sHour, min = sMinute, sec = sSeconds });
end

--去除首尾空白字符
-- @param s     原始字符串
-- @return      去除首尾空白字符的字符串
function Common.Trim(s)
    return(string.gsub(s, "^%s*(.-)%s*$", "%1"))
end

-- 为Url添加常规参数
-- @param  originalUrl    原始Url
-- @return                返回添加参数后的Url  
function Common.AppendGeneralParametersForUrl(originalUrl)
    local destUrl = originalUrl;
    local userData = Common.GetUserData();
    local platId = userData.sPlatID;
    local partition = userData.sPartition;
    local roleId = userData.sRoleId;
    local areaId = userData.sArea;
    local accessToken = userData.sAccessToken;
    local payToken = userData.sPayToken;

    local urlParameters = string.format("sPlatId=%s&sPartition=%s&sRoleId=%s&sArea=%s&access_token=%s&pay_token=%s", platId, partition, roleId, areaId,accessToken,payToken);
    if string.find(originalUrl, "?") ~= nil then
        destUrl = originalUrl .. "&" .. urlParameters;
    else
        destUrl = originalUrl .. "?" .. urlParameters;
    end
    return destUrl;
end

-- 获取gameObject在Hierarhy下的路径
-- @param gameObject 节点
function Common.GetGameObjectPath(gameObject)
    local path = "";
    local tmpTransform = gameObject.transform;
    while tmpTransform ~= nil do
        path = "/" .. tmpTransform.name .. path;
        tmpTransform = tmpTransform.parent;
    end
    return string.sub(path, 2);
end

local actionSandboxTb = {};
function Common.LoadAction(group, luaName)
	local SandBox = require("SandBox")
	local sandbox = SandBox:New();
	sandbox:LoadAction(group, luaName)
    actionSandboxTb[luaName] = sandbox;
end

function Common.GetActionSandbox(luaName)
    return actionSandboxTb[luaName];
end

--region 给灵犀使用的适配接口，业务中以下参数为特殊情况时修改下面接口
function Common.GetArea()
    return Common.GetUserData().sArea;
end

function Common.GetPartition()
    return Common.GetUserData().sPartition;
end

function Common.GetPlatId()
    return Common.GetUserData().sPlatID;
end

-- pandora连接的环境
-- true：测试环境，false：正式环境
function Common.IsPandoraTestEnv()
    return Common.GetFunctionSwitch("test");
end
--endregion

--挂载Pixui panel
function Common.MountPixuiPanel(pixuiPanel)
    if pixuiPanel == nil then
        Logger.ERROR("待挂载的pixui 面板为空");
        return;
    end
    
    local pixuiRootPath = "Canvas";
    local root = UnityEngine.GameObject.Find(pixuiRootPath);
    if root == nil then
        Logger.DEBUG("未找到pixui 根节点，pandora 工程内运行请忽略，游戏包内运行需查找原因");
        return;
    end

    pixuiPanel.transform:SetParent(root.transform);
    local transform = pixuiPanel.transform;
    transform.localScale = UnityEngine.Vector3.one;
    transform.localPosition = UnityEngine.Vector3.zero;
end

-- 数据暂存接口，用于pixui活动把数据暂存到内存中
function Common.SetDataStash(appId, appKey, dataKey, dataValue)
    return PxFrame.SetDataStash(appId, appKey, dataKey, dataValue)
end

function Common.GetDataStash(appId, dataKey)
    return PxFrame.GetDataStash(appId, dataKey)
end

function Common.ClearDataStash(appId, appKey)
    return PxFrame.ClearDataStash(appId, appKey)
end

function Common.IsProductEnvironment()
    return CSharpInterface.IsProductEnvironment();
end

function Common.GetPandoraGameObject()
    return CSharpInterface.GetPandoraGameObject();
end

--自定义Tdm上报
-- @param json          json格式的上报内容，key必须和TDM上创建的数据表字段一致
-- @param eventName     在TDM上创建的数据表
-- @param srcId         创建的TDM数据表所属的srcId
function Common.ReportCustomDataByTdm(json,eventName,srcId)
    Common.SafeCall(CSharpInterface.ReportCustomDataByTdm,json,eventName,srcId)
end
