-- 事件处理基础设施
require "Logger";

local CSharpInterface = com.tencent.pandora.CSharpInterface;

EventDispatcher = {};

-- key为 event eventType, value为{eventType, listener, args}列表
-- 将Common中产生的CallId作为EventType时tostring一下，确保eventMap的哈希结构
local eventMap = {}
local platform = UnityEngine.Application.platform;
local WINDOWS_EDITOR = 7;

-- 此处 ... 传递的不定参数将会在回调中调用,比如传递的self参数
function EventDispatcher.AddEventListener(eventType, listener, ...)
	if listener == nil then
		--Logger.WARN("listener为空, eventType: " .. eventType);
		return;
	end

	if type(listener) ~= "function" then
		Logger.ERROR("listener类型不是函数, eventType: " .. eventType .. " 实际类型： " .. type(listener));
		return;
	end

	eventType = tostring(eventType);
	if eventMap[eventType] == nil then
		eventMap[eventType] = {};
	end
	local eventList = eventMap[eventType];
	for i,v in ipairs(eventList) do
		if v.eventType == eventType and v.listener == listener then
			Logger.WARN("重复添加的事件监听, eventType: " .. eventType);
			return;
		end
	end

	local event = {};
	event.eventType = eventType;
	event.listener = listener;
	event.argsLength = select('#', ...); --记录AddEventListener时带的参数长度，包括nil
	event.args = {...};
	table.insert(eventList, event);
end

function EventDispatcher.RemoveEventListener(eventType, listener)
	eventType = tostring(eventType);
	if EventDispatcher.HasEventListener(eventType) == false then
		return;
	end

	local eventList = eventMap[eventType];
	for i = #eventList, 1, -1 do
		local event = eventList[i];
		if event.eventType == eventType and event.listener == listener then
			table.remove(eventList, i);
		end
	end

	if #eventList == 0 then
		eventMap[eventType] = nil;
	end
end

function EventDispatcher.RemoveEventAllListener(eventType)
	eventType = tostring(eventType);
	if EventDispatcher.HasEventListener(eventType) == false then
		return;
	end
	
	eventMap[eventType] = nil;
end

-- 此处的...不定参数会添加到AddEventListener时添加的不定参数之后，
-- 两处的参数合并后再传递给事件处理函数
function EventDispatcher.DispatchEvent(eventType, ...)
	eventType = tostring(eventType);
	if EventDispatcher.HasEventListener(eventType) == false then
		return;
	end
	local params = {...};
	local paramsLength = select('#', ...); -- DispatchEvent时所带参数长度，包括nil
	local eventList = eventMap[eventType];
	-- 迭代器迭代过程中删除元素有问题，故先创建一个局部数组，保证迭代过程中不删除其元素
	local shadowEventList = EventDispatcher.CreateShadowEventList(eventList);
	for i,v in ipairs(shadowEventList) do
		local eventParams = {};
		local paramIndex = 0;
		local args = v.args or {};
		for j,p in pairs(args) do
			local index = paramIndex + j;
			table.insert(eventParams, index, p);
		end
		paramIndex = v.argsLength or 0;
		for j,p in pairs(params) do
			local index = paramIndex + j;
			table.insert(eventParams, index, p);
		end
		if v.listener ~= nil then
			if platform == WINDOWS_EDITOR then
				v.listener(unpack(eventParams, 1, v.argsLength + paramsLength));
			else
				xpcall(function() 
					v.listener(unpack(eventParams, 1, v.argsLength + paramsLength)); 
				end,
				function ( err  )
					local firstParams = paramsLength >= 1 and params[1] or ""; 
					local luaErrorTable = {
						"event handler error, eventtype: ";
						tostring(eventType);
						"  ";
						err;
						"\n";
						debug.traceback();
						"\nfirstParams: \n";
						tostring(firstParams);
						"\n";
					}
					local luaErrorString =  table.concat( luaErrorTable, "" );
					Logger.DEBUG("luaErrorString:=" .. luaErrorString);
					CSharpInterface.ReportLuaError(luaErrorString);
				end)
			end
		end
	end
end

function EventDispatcher.CreateShadowEventList(eventList)
	if #eventList <= 1 then
		return eventList;
	end
	local result = {};
	for i,v in ipairs(eventList) do
		result[#result + 1] = v;
	end
	return result;
end


function EventDispatcher.HasEventListener(eventType)
	eventType = tostring(eventType);
	if eventMap[eventType] == nil then
		return false;
	end

	if #eventMap[eventType] == 0 then 
		return false;
	end
	
	return true;
end

