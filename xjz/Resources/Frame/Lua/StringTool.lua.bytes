StringTool = {};

local StringTool = StringTool

function StringTool.Split(source, delimiter)
    local result = {};
    for m in string.gmatch(source, "[^" .. delimiter .. "]+") do
        table.insert(result, m);
    end
    return result;
end

-- 解析道聚城配置中时间字段：2017-04-18 23:59:59， 返回{year=2017,month=4,day=18,hour=23,minute=59,second=59}
function StringTool.ParseDate(dateStr)
    local rough = StringTool.Split(dateStr, " ");
    local firstTbl = StringTool.Split(rough[1], "-");
    local secondTbl = StringTool.Split(rough[2], ":");
    return {["year"] = firstTbl[1], ["month"] = firstTbl[2], ["day"] = firstTbl[3],
            ["hour"] = secondTbl[1], ["min"] = secondTbl[2], ["sec"] = secondTbl[3]};
end

-- 将字符串编码为Url字串
function StringTool.UrlEncode(s)
    local s = string.gsub(s, "([^%w%.%- ])", function(c) return string.format("%%%02X", string.byte(c)); end);
    return string.gsub(s, " ", "+")
end

-- 将Url字符串解码为普通字串
function StringTool.UrlDecode(s)
    local s = string.gsub(s, '%%(%x%x)', function(h) return string.char(tonumber(h, 16)); end);
    return s  
end

-- 过滤非法字符
function StringTool.FilterInvalidCharacter(content)
    local ss = {}
    local k = 1
    if content == "" or content == nil then
        return "";
    end
    while true do
        if k > #content then break end
        local c = string.byte(content,k)
        if not c then break end
        if c<192 then
            table.insert(ss, string.char(c))
            k = k + 1
        elseif c<224 then
            k = k + 2
        elseif c<240 then
        if c>=228 and c<=233 then
            local c1 = string.byte(content,k+1)
            local c2 = string.byte(content,k+2)
            if c1 and c2 then
            local a1,a2,a3,a4 = 128,191,128,191
                if c == 228 then a1 = 184
                    elseif c == 233 then a2,a4 = 190,c1 ~= 190 and 191 or 165
                    end
                if c1>=a1 and c1<=a2 and c2>=a3 and c2<=a4 then
                    table.insert(ss, string.char(c,c1,c2))
                    end
                end
            end
            k = k + 3
        elseif c<248 then
             k = k + 4
        elseif c<252 then
            k = k + 5
        elseif c<254 then
            k = k + 6
        end
    end
    return table.concat(ss)
end

--[[
utf8 encoding
Number of bytes    Byte 1      Byte 2      Byte 3      Byte 4
1                  0xxxxxxx            
2                  110xxxxx    10xxxxxx        
3                  1110xxxx    10xxxxxx    10xxxxxx    
4                  11110xxx    10xxxxxx    10xxxxxx    10xxxxxx
]]
-- 获取Utf8字串长度
function StringTool.GetUtf8StrLength(str)
    local lenInByte = #str
    local len, i = 0, 1
    while i <= lenInByte do
        local curByte = string.byte(str, i)
        local byteCount = 1
        if curByte >= 0 and curByte <= 127 then
            byteCount = 1
        elseif curByte >= 192 and curByte <= 223 then
            byteCount = 2
        elseif curByte >= 224 and curByte <= 239 then
            byteCount = 3
        elseif curByte >= 240 and curByte <= 247 then
            byteCount = 4
        end

        i = i + byteCount
        len = len + 1
    end

    return len
end

-- 获取Utf8字串字符信息列表
function StringTool.GetUtf8StrIndexInfo(str)
    local characterInfo = {}
    local lenInByte = #str
    local len, i = 0, 1
    while i <= lenInByte do
        local curByte = string.byte(str, i)
        local byteCount = 1
        if curByte >= 0 and curByte <= 127 then
            byteCount = 1
        elseif curByte >= 192 and curByte <= 223 then
            byteCount = 2
        elseif curByte >= 224 and curByte <= 239 then
            byteCount = 3
        elseif curByte >= 240 and curByte <= 247 then
            byteCount = 4
        end

        table.insert(characterInfo, {sidx = i, bytes = byteCount})
        i = i + byteCount
        len = len + 1
    end

    return characterInfo, len
end

-- 移除Utf8字串中指定子字串
function StringTool.Utf8RemoveSubStr(str, istart, iend)
    local characterInfo = StringTool.GetUtf8StrIndexInfo(str)
    return StringTool.Utf8RemoveSubStrWithIndexInfo(str, istart, iend, characterInfo)
end

-- 移除Utf8字串中指定子字串
function StringTool.Utf8RemoveSubStrWithIndexInfo(str, istart, iend, characterInfo)
    local cnt = 0
    for i=istart, iend do
        cnt = cnt + characterInfo[i].bytes
    end
    local startInByte = characterInfo[istart].sidx
    local endInByte = startInByte + cnt
    local firstStr = string.sub(str, 1, startInByte-1)
    local secondStr = string.sub(str, endInByte, lenInByte)
    return firstStr .. secondStr
end

-- 将字串内容缩减到恰好能装进compText的长度, 字串将以"..."结尾, 若原字串中有换行符, 换行符会被删除
-- 注意: 若compText在初始化时处于非激活态, 则该函数可能需要在compText激活后延迟调用才能生效,
--      原因是该函数需要compText中的setting为正确值才能正确计算字串长度, 而pandora text在激活后才会将字体设置进组件
-- 该函数仅支持UGUI Text组件
function StringTool.ShrinkTextByComponent(compText, str)
    local size = compText.transform.rect.size
    local setting = compText:GetGenerationSettings(size)
    setting.scaleFactor = 1
    local generator = compText.cachedTextGeneratorForLayout
    local arr = StringTool.Split(str, "\n")
    str = table.concat(arr)
    local width = generator:GetPreferredWidth(str, setting)
    if width <= size.x then
        return str
    end

    local characterInfo = StringTool.GetUtf8StrIndexInfo(str)
    local characterLen, byteLen = #characterInfo, #str
    local percentage = size.x / width
    local targetByteLen = math.floor(percentage * byteLen)
    local cnt = 0
    local targetInfoIdx = 1
    for i=1, characterLen do
        cnt = cnt + characterInfo[i].bytes
        targetInfoIdx = i
        if cnt >= targetByteLen then
            break
        end
    end

    if targetInfoIdx > 3 then
        targetInfoIdx = targetInfoIdx - 3
    end

    -- algorithm above can not calculate the exact character counts that just fit in the text area
    -- so we do some fix below
    -- fill empty area until no word can fit in.
    local newStr = string.sub(str, 1, characterInfo[targetInfoIdx].sidx - 1) .. "..."
    local sizeX = size.x
    for i = targetInfoIdx + 1, characterLen do
        local tmpstr = string.sub(str, 1, characterInfo[i].sidx - 1) .. "..."
        width = generator:GetPreferredWidth(tmpstr, setting)
        if width > sizeX then
            break
        end
        if i == characterLen then
            newStr = str
            break
        end
        newStr = tmpstr
    end

    return newStr
end

return StringTool
